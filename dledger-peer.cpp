#include "dledger-peer.hpp"
#include <chrono>
#include <ndn-cxx/util/scheduler.hpp>
#include <boost/asio.hpp>
#include <ndn-cxx/util/sha256.hpp>

namespace ndn {
namespace dledger {

LedgerRecord::LedgerRecord(shared_ptr<const Data> contentObject,
                           int weight, int entropy, bool isArchived)
  : block(contentObject)
  , weight(weight)
  , entropy(entropy)
  , isArchived(isArchived)
{
  //Ptr<UniformRandomVariable> x = CreateObject<UniformRandomVariable>();
  //int num = static_cast<int>(x->GetValue()*100);
  //if (num > 95) {
  //{
  //  isASample = true;
  //  creationTime = Simulator::Now();
  //}
}

Peer::Peer()
  : m_face(m_ioService)
  , m_scheduler(m_ioService)
  , m_firstTime(true)
  , m_syncFirstTime(true)
{
}

std::vector<std::string>
Peer::GetApprovedBlocks(shared_ptr<const Data> data)
{
  std::vector<std::string> approvedBlocks;
  auto content = ::ndn::encoding::readString(data->getContent());
  int nSlash = 0;
  const char *st, *ed;
  for(st = ed = content.c_str(); *ed && *ed != '*'; ed ++){
    if(*ed == ':'){
      if(nSlash >= 2){
        approvedBlocks.push_back(std::string(st, ed));
      }
      nSlash = 0;
      st = ed + 1;
    }else if(*ed == '/'){
      nSlash ++;
    }
  }
  if(nSlash >= 2){
    approvedBlocks.push_back(std::string(st, ed));
  }

  return approvedBlocks;
}

void
Peer::ScheduleNextGeneration()
{
  //NS_LOG_FUNCTION_NOARGS();
  if (m_firstTime) {
    signed int startingPoint = 1;
    m_sendEvent = m_scheduler.scheduleEvent(time::seconds(startingPoint), [this] { GenerateRecord(); });
    m_firstTime = false;
  } else {
    if (m_frequency == 0) {
      m_sendEvent = m_scheduler.scheduleEvent(time::seconds(1), [this] { GenerateRecord(); });
    } else {
      m_sendEvent = m_scheduler.scheduleEvent(time::seconds(m_frequency), [this] { GenerateRecord(); });
    }
  }
}

void
Peer::OnData(const Interest& interest, const Data& data)
{

}

void
Peer::OnNack(const Interest& interest, const lp::Nack& nack)
{

}

void
Peer::OnTimeout(const Interest& interest)
{
}

void
Peer::UpdateWeightAndEntropy(shared_ptr<const Data> tail, std::set<std::string>& visited, std::string nodeName)
{
}

// Generate a new record and send out notif and sync interest
void
Peer::GenerateRecord()
{
  //NS_LOG_FUNCTION_NOARGS();
  if (m_missingRecords.size() > 0) {
    //NS_LOG_INFO("Missing record number: " << m_missingRecords.size());
    ScheduleNextGeneration();
    return;
  }
  std::set<std::string> selectedBlocks;
  int tryTimes = 0;
  for (int i = 0; i < m_referredNum; i++) {
    auto referenceIndex = rand() % (m_tipList.size() - 1);
    auto reference = m_tipList.at(referenceIndex);
    bool isArchived = m_ledger.find(reference)->second.isArchived;

    // cannot select a block generated by myself
    // cannot select a confirmed block
    while (m_routablePrefix.isPrefixOf(reference) || isArchived) {
      referenceIndex = rand() % (m_tipList.size() - 1);
      reference = m_tipList.at(referenceIndex);
      isArchived = m_ledger.find(reference)->second.isArchived;
    }
    selectedBlocks.insert(reference);
    if (i == m_referredNum - 1 && selectedBlocks.size() < 2) {
      i--;
      tryTimes++;
      if (tryTimes > 10) {
        //NS_LOG_INFO("Try times used up: " << tryTimes);
        ScheduleNextGeneration();
        return;
      }
    }
  }

  std::string recordContent = "";
  for (const auto& item : selectedBlocks) {
    recordContent += ":";
    recordContent += item;
    m_tipList.erase(std::remove(m_tipList.begin(),
                                m_tipList.end(), item), m_tipList.end());
  }
  // to avoid the same digest made by multiple peers, add peer specific info
  recordContent += "***";
  recordContent += m_routablePrefix.toUri();

  // generate digest as a name component
  std::istringstream sha256Is(recordContent);
  ::ndn::util::Sha256 sha(sha256Is);
  std::string recordDigest = sha.toString();
  sha.reset();

  // generate a new record
  // Naming: /dledger/nodeX/digest
  Name recordName(m_routablePrefix);
  recordName.append(recordDigest);
  auto record = std::make_shared<Data>(recordName);
  record->setContent(::ndn::encoding::makeStringBlock(::ndn::tlv::Content, recordContent));
  m_keyChain.sign(*record);

  // attach to local ledger
  m_ledger.insert(std::pair<std::string, LedgerRecord>(recordName.toUri(), LedgerRecord(record)));
  // add to tip list
  m_tipList.push_back(recordName.toUri());

  // update weights of directly or indirectly approved blocks
  std::set<std::string> visited;
  UpdateWeightAndEntropy(record, visited, recordName.getSubName(0, 2).toUri());
  //NS_LOG_INFO("NewRecord: visited records size: " << visited.size()
  //            << " unconfirmed depth: " << log2(visited.size() + 1));

  Name notifName(m_mcPrefix);
  notifName.append("NOTIF").append(m_routablePrefix.getSubName(1).toUri()).append(recordDigest);
  Interest notif(notifName);

  //NS_LOG_INFO("> NOTIF Interest " << notif->getName().toUri());
  m_face.expressInterest(notif, bind(&Peer::OnData, this, _1, _2),
                                bind(&Peer::OnNack, this, _1, _2),
                                bind(&Peer::OnTimeout, this, _1)); 
  ScheduleNextGeneration();
}

}
}

int
main(int argc, char** argv)
{
  return 1;
}
